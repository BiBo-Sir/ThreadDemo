# ThreadDemo
C# 线程

学习链接：
https://www.cnblogs.com/xugang/archive/2010/11/03/1867945.html

多线程出现的原因：
	为了解决负载均衡的问题,充分利用CPU资源，采用多线程的方式去同时完成几件事情而不互相干扰。
		
	多线程的好处:
	1.使用线程可以把占据时间长的程序中的任务放到后台去处理
	2.用户界面更加吸引人,这样比如用户点击了一个按钮去触发某件事件的处理,可以弹出一个进度条来显示处理的进度
	3.程序的运行效率可能会提高
	4.在一些等待的任务实现上如用户输入,文件读取和网络收发数据等,线程就比较有用了.

	多线程的缺点:
	1.如果有大量的线程,会影响性能,因为操作系统需要在它们之间切换.
	2.更多的线程需要更多的内存空间
	3.线程中止需要考虑对程序运行的影响.
	4.通常块模型数据是在多个线程间共享的,需要防止线程死锁情况的发生
	
	只要有一个前台线程在运行，应用程序的进程尽在运行。如果多个前台线程在运行，而Main()方法结束了，应用程序
	的进程就仍然是激活的，直到所有的前台线程完成其任务为止。
	默认情况下，用Thread类创建的线程是前台线程。线程池中的线程总是后台线程。
	
线程池(ThreadPool)：
	为什么使用线程池？
		当需要创建许多花费时间非常短的异步操作来完成工作时，这个时候为每一个异步操作创建一个线程是不合适的，因为
		创建线程的成本比较高，因为创建和销毁线程都需要花费时间。
		
	ThreadPool中的线程不用手动开始，也不能手动取消，你要做的只是把工作函数排入线程池，剩下的工作将由系统自动完成，
	也就是说我们不能控制线程池中的线程。如果想对线程进行更多的控制，那么就不适合使用线程池。
	
	以下情况不宜使用ThreadPool类而应该使用大怒的Thread类：
	1）线程的时间非常长
	2）需要为线程指定优先级
	3）执行过程中需要对线程进行操作，如：睡眠、挂起等
	
	我们可以使用System.Threading.ThreadPool类型来利用线程池。线程池由Common Language Runtime（CLR）进行管理，
	这意味着每一个CLR只能有一个线程池实例。ThreadPool类型有一个“QueueUserWorkItem”静态方法，这个静态方法接收一个委托，该委托代表一个用户自定义的异步操作。
	当这个方法被调用时，这个委托就进入内部队列，这个时候，如果线程池中没有线程，则会创建一个新的工作线程，然后将这个委托（第一个）放入队列中。
	QueueUserWorkItem()方法：将工作任务排入线程池。
  每排入一个工作函数，相当于请求创建一个线程。

　如果先前的操作执行完毕后，我们又放置了一个新的操作到线程池，那么我们可能会重用上一次操作的那个工作线程。
  如果我们放置新的操作的时候，线程池中的线程数已达到上限，那么新的操作会在队列中等待，直到线程池中有可用工作线程为止。

 需要注意的是，我们尽量在线程池中放置一些需要花费较少时间既能完成的操作，而不要放置需要花费大量时间才能完成的操作，同时不要阻塞工作线程。
 如果不是这样，工作线程会变得非常繁忙，以至于不能响应用户操作，同时也会导致性能问题以及难以调试的错误。
另外，线程池中的工作线程都是后台线程，这意味着当所有的前台线程执行完毕后，后台线程会被停止执行
